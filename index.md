## Welcome to GitHub Pages

# java 关键字  
1.static   
https://www.cnblogs.com/dolphin0520/p/3799052.html  
2.final  
https://www.cnblogs.com/dolphin0520/p/3736238.html  

# java数据结构与算法  
1.java中常用的数据结构List，Set，Map等的区别与联系  
https://blog.csdn.net/qq_34337272/article/details/80294307  
2.树基本概念及二叉树（BinaryTree）的设计与实现  
https://blog.csdn.net/javazejian/article/details/53727333  

# java并发

1.java中synchronized关键字和ReentrantLock的区别：
相同点：两者都是可重入锁，在实现可重入性时，两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。
        但是两者在可重入性的实现上不一样，ReentrantLock在请求获取锁时会进行一个判断，判断当前是否有线程持有锁，持有锁的线程是否是当前请求锁的线程  

区别：  
1.1 实现上：synchronized由jvm实现，而ReentrantLock由jdk实现  
1.2 性能上：在jvm未对synchronized关键字做优化之前差ReentrantLock很多，但是synchronized引入偏向锁、轻量级锁、和自旋以后两者在性能上就差别不大了   
1.3 功能上：synchronized的实现更简单，加锁和解锁的工作由jvm来做，而ReentrantLock则需要用户手动的进行加锁和释放锁，为避免遗忘释放锁而造成阻塞在                finally语句中完成释放锁是不错的选择  
1.4 ReenTrantLock独有的能力：  
    ReentrantLock可以指定是非公平锁(默认)or公平锁，而synchronized只能是非公平锁。  
    ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个                             线程要么唤醒全部线程。  
    ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。 
1.5 Reentrantlock实现原理见mmpfiles.

2.AQS详谈
  队列同步器AbstractQueuedSynchronizr是用来构建锁或者其他同步组件的基础框架，它使用了一个int型成员变量来表示同步状态，通过FIFO队列来完成资源获取线  程的排队工作，同步器使用的方式是继承，子类通过继承同步器并实现其抽象方法来管理同步状态，详细如下：  
  https://www.cnblogs.com/waterystone/p/4920797.html
  
3.可重入性，及synchronized可重入的实现原理  
   可重入指的是一个线程在已经得到某个对象的锁时，在运行过程中再次请求该锁会成功。每个锁关联一个线程持有者和计数器，当计数器为0时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为0，则释放该锁。  

4.jvm对java原生锁(synchronized)做的优化：  
1.自旋锁：在线程请求锁时，如果已有线程占有当前请求的锁，请求的线程并不马上放弃处理器的执行时间，而是稍等一会看是否有线程很快就会释放锁，可以让线程做           一个忙循环(自旋),自旋锁默认情况下是关闭的，需要用虚拟机参数来开启。   
2.锁消除：  
3.锁粗化：如果连续的零碎操作需要对同一个对象加锁，将会把整个锁同步范围扩大到整个操作序列外部，减少频繁互斥同步带来的性能损耗。    
4.轻量级锁：在代码进入同步块的时候，如果此同步对象未被锁定，虚拟机会在当前线程的栈帧中建立一个名为锁记录(lock record)的空间，用于存储锁对象目前。              Mark Word拷贝(displaced mark word)，然后虚拟机将会使用CAS操作尝试将对象的Mark Word更新为指向lock record,如果这个操作成功则拥有了该对            象的锁，Mark Word的锁标志为将会变成00，如果操作失败，虚拟机会检查对象的Mark Word是否指向了当前线程的栈帧，是则重入，否则说明当前锁对象            已经被其他线程抢占了，如果有多个线程竞争同一个锁则轻量级锁将不在有效，转变为重量级锁，后面线程阻塞。  
5.偏向锁： 当线程第一次获取锁对象的时候，虚拟机会把对象头的标志位设为01，进入偏向模式，同时使用CAS操作将持有偏向锁的线程的ID记录在Mark Word中，如果           CAS操作成功，则以后持有偏向锁的线程进入这个锁相关的同步块时不用再进行任何操作，当有另外一个线程尝试获取这个锁时偏向模式结束，根据锁对象目           前是否处于锁定状态，撤销偏向后恢复到轻量级锁状态或者无锁状态。
            

# MySQL数据库
1.mysql中两种主要的存储引擎MyISAM与InnoDB的区别  
  
  1.1 InnoDB存储引擎支持事务、行锁设计、支持外键，但是默认的读取不会产生锁。InnoDB通过使用多版本并发控制(MVCC)来获得高并发性，并实现了SQL默认的4种隔离级别，默认状态下是Repeattable，使用next-key locking来避免幻读问题，除此之外还提供了插入缓冲、二次写、自适应哈希索引、预读等高可用功能，表中数据的存储采用了聚集的方式。  
  1.2 MyISAM存储引擎不支持事务、表锁设计，支持全文索引，它的缓冲池只缓存索引文件而不缓存数据文件  
  
2. 数据库的4种隔离级别，每种级别可能会存在的问题  
  2.1 未提交读(read uncommitted) 可能会造成脏读问题，即读取到还未提交的事务操作的数据  
  2.2 提交读(read committed) 修复了脏读问题，但可能会造成不可重复读问题，即读取到已经提交的数据  
  2.3 重复读(repeatable read) 是MySQL默认的隔离级别，修复了脏读、不可重复读的问题，但可能会造成幻读问题，使用next-key locking解决了这一问题
  2.4 可序列化读(serializable) 最严格的级别避免了所有的问题，但是资源开销很大  
  
3. MySQL中的锁  
  3.1 数据库中使用锁是为了对资源进行并发访问，并提高数据一致性和完整性。  
  3.2 lock与latch： lock的对象是事务，如表、页、行，lock对象一般在事务commit或者rollback后进行释放   
                      lock                                                latch  
      对象             事务                                                线程  
      保护             数据库的内容                                         内存数据结构
      持续时间         整个事务过程                                          临界资源  
      模式             表锁、行锁、页锁                                      读写锁、互斥量  
      死锁             通过资源等待图和超时机制进行检测                        无死锁检测机制  
      存在于           lock manager的hash表中                                每个数据结构对象  
  
4. 锁的类别  
   mysql中最主要有两种锁： 
   共享锁：S Lock允许事务读一行数据  
   排他锁：X Lock允许事务删除一行数据  
   InnoDB存储引擎为了支持在不同的粒度上进行加锁，而引入了一种额外的加锁方式，意向锁：  
   意向共享锁：IS Lock 获得表中某几行的共享锁  
   意向排它锁：IX Lock 获得表中某几行的排他锁  
   select ... from ... lock in share mode  加共享锁  
   select ... from ... for update 加排他锁  
  
5.一致性非锁定读  
   指的是innoDB引擎通过多版本并发控制来读取当前执行时间数据库中行数据，如果正在执行update或者delete操作，这时读取操作不会等待锁的释放，而是去读取一个快照数据(指的是改行之前版本的数据，听过undo实现)，这样大大提高了并发性。  
     
6.锁的三种算法：  
  6.1 Record Lock：单个行记录上的锁  
  6.2 Gap Lock：间隙锁，锁定一个范围，但不包含记录本身  
  6.3 Next-key Lock：前两者的集合，并且锁定本身，查询的索引含有唯一性属性时会进行降级为record lock仅锁住索引本身  
  
7.死锁的判定原理  
7.1 概念：两个或两个以上的事务在执行的过程中，因争夺资源而造成的一种互相等待的现象
7.2 死锁的检测：wait-for graph
7.3 死锁的解决:超时机制，当等待的时间超过某个设置的阈值时，其中一个事务进行回滚。  
  
8.索引  
  8.1 聚集索引：按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，叶子节点也叫数据页，聚集索引能够在B+树叶子节点上直接找到数                据。  
  8.2 非聚集索引：叶子节点不包含表的全部数据，叶子节点中存放着键值，以及一个书签用于告诉InnoDB引擎在哪可以找到这些行数据。 
    
9.B+树索引和hash索引的区别  
  9.1 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；    
  9.2 从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；  
  9.3 同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；  
  9.4 哈希索引也不支持多列联合索引的最左匹配规则；  
  9.5 B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。  
    
10.B+树索引和B树索引的区别：
   B-树和B+树最重要的一个区别就是B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数
   那么Mysql如何衡量查询效率呢？磁盘IO次数，B-树（B类树）的特定就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，当查询数据的时候，最好的情况就是很快找到目标索引，然后读取数据，使用B+树就能很好的完成这个目的，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时啊！），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。  
另一个优点是什么，B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。  
(数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）)  
11.MySQL的中的日志  
  11.1 错误日志：对MySQL的启动、运行、关闭过程进行记录，可通过错误日志定位MySQL存在的问题  
  11.2 慢查询日志：定位存在问题的SQL语句，从而进行SQL语句层面的优化，在默认的情况下MySQL数据库并不启动慢查询日志，需要手动开启。  
  11.3 查询日志：记录了所有对MySQL的请求信息。 
  11.4 二进制日志：记录了对MySQL数据库执行更改的所有操作，但是不包括show和select这类没有对数据库进行修改的操作。  
       作用：
       1)恢复 2)复制 3)审计
  11.5 重做日志(redo)：重做日志文件用于实现事务的持久性。由两部分组成：  
                      1)是内存中的重做日志缓冲，是易失的  
                      2)是重做日志文件，是持久的，事务提交时必须将事务的日志全部写入重做日志文件进行持久化，待事务的commit操作完成才算完成，但是在                         数据库中也允许非持久化的操作，为了提高数据库的性能，可每隔一段时间才进行一次将事务日志从日志缓存中写入重做日志  
                        
       二进制日志和重做日志的区别：二进制日志主要用来进行pointtotime的恢复及主从复制环境的建立，它在数据库的上层产生，是一种逻辑日志，对应的是SQL语                                 句，它不只针对InNoDB存储引擎，数据库中的任何引擎对数据库的修改都会产生二进制日志，在事务提交完成后对它进行一次修                                   改。  
                                重做日志在InNoDB存储引擎层产生，它是一种物理格式日志，记录的是对每个页的修改。  
   11.6 undo日志：用来帮助事务进行回滚和MVCC功能，当执行rollback语句时可利用undo信息将数据回滚到修改前的样子(并不是事务开始前的样子)
   11.7 purge：用于完成delete和update的最终操作，当执行一条delete语句时，记录并不会直接被删除，而只是将delete flag标记为1，标记已删除，最终的删除                任务由purge完成  
                                
                      
                      




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  







