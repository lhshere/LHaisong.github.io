## Welcome to GitHub Pages

# java 关键字  
1.static   
https://www.cnblogs.com/dolphin0520/p/3799052.html  
2.final  
https://www.cnblogs.com/dolphin0520/p/3736238.html  

# java数据结构与算法  
1.java中常用的数据结构List，Set，Map等的区别与联系  
https://blog.csdn.net/qq_34337272/article/details/80294307  
2.树基本概念及二叉树（BinaryTree）的设计与实现  
https://blog.csdn.net/javazejian/article/details/53727333  

# java并发

1.java中synchronized关键字和ReentrantLock的区别：
相同点：两者都是可重入锁，在实现可重入性时，两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。
        但是两者在可重入性的实现上不一样，ReentrantLock在请求获取锁时会进行一个判断，判断当前是否有线程持有锁，持有锁的线程是否是当前请求锁的线程  

区别：  
1.1 实现上：synchronized由jvm实现，而ReentrantLock由jdk实现  
1.2 性能上：在jvm未对synchronized关键字做优化之前差ReentrantLock很多，但是synchronized引入偏向锁、轻量级锁、和自旋以后两者在性能上就差别不大了   
1.3 功能上：synchronized的实现更简单，加锁和解锁的工作由jvm来做，而ReentrantLock则需要用户手动的进行加锁和释放锁，为避免遗忘释放锁而造成阻塞在                finally语句中完成释放锁是不错的选择  
1.4 ReenTrantLock独有的能力：  
    ReentrantLock可以指定是非公平锁(默认)or公平锁，而synchronized只能是非公平锁。  
    ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个                             线程要么唤醒全部线程。  
    ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。  
1.5 Reentrantlock实现原理见mmpfiles.

2.AQS详谈
  队列同步器AbstractQueuedSynchronizr是用来构建锁或者其他同步组件的基础框架，它使用了一个int型成员变量来表示同步状态，通过FIFO队列来完成资源获取线  程的排队工作，同步器使用的方式是继承，子类通过继承同步器并实现其抽象方法来管理同步状态，详细如下：  
  https://www.cnblogs.com/waterystone/p/4920797.html
  
3.可重入性，及synchronized可重入的实现原理  
   可重入指的是一个线程在已经得到某个对象的锁时，在运行过程中再次请求该锁会成功。每个锁关联一个线程持有者和计数器，当计数器为0时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为0，则释放该锁。  

4.jvm对java原生锁(synchronized)做的优化：  
4.1.自旋锁：在线程请求锁时，如果已有线程占有当前请求的锁，请求的线程并不马上放弃处理器的执行时间，而是稍等一会看是否有线程很快就会释放锁，可以让线程做           一个忙循环(自旋),自旋锁默认情况下是关闭的，需要用虚拟机参数来开启。   
4.2.锁消除：  
4.3.锁粗化：如果连续的零碎操作需要对同一个对象加锁，将会把整个锁同步范围扩大到整个操作序列外部，减少频繁互斥同步带来的性能损耗。    
4.4.轻量级锁：在代码进入同步块的时候，如果此同步对象未被锁定，虚拟机会在当前线程的栈帧中建立一个名为锁记录(lock record)的空间，用于存储锁对象目前。              Mark Word拷贝(displaced mark word)，然后虚拟机将会使用CAS操作尝试将对象的Mark Word更新为指向lock record,如果这个操作成功则拥有了该              对象的锁，Mark Word的锁标志为将会变成00，如果操作失败，虚拟机会检查对象的Mark Word是否指向了当前线程的栈帧，是则重入，否则说明当前锁              对象已经被其他线程抢占了，如果有多个线程竞争同一个锁则轻量级锁将不在有效，转变为重量级锁，后面线程阻塞。  
4.5.偏向锁： 当线程第一次获取锁对象的时候，虚拟机会把对象头的标志位设为01，进入偏向模式，同时使用CAS操作将持有偏向锁的线程的ID记录在Mark Word中，如             果CAS操作成功，则以后持有偏向锁的线程进入这个锁相关的同步块时不用再进行任何操作，当有另外一个线程尝试获取这个锁时偏向模式结束，根据锁对             象目前是否处于锁定状态，撤销偏向后恢复到轻量级锁状态或者无锁状态。  
  
5.java Object中的wait()、notify()方法和ReentrantLock中Conditon中的await()、signal()方法的区别：  
        https://blog.csdn.net/u011955252/article/details/78303998  
          
6.java中与线程有关的常见方法：  
  6.1 wait()方法，存在于Object中，由object调用，让线程让出当前的monitor对象进入等待，但前提是已经获得了对象的monitor对象，会释放锁  
  6.2 notify()方法，存在于Object中，用于唤醒等待池中的线程，但是不能确定哪个会被唤醒，调用前当前对象的monitor对象必须要已经被获取  
  6.3 sleep()方法，存在thread中，让线程休眠，但不会释放锁  
  6.4 yield()方法，存在yield中，表示线程愿意放弃当前的执行而把机会让给与它具有相同优先级的线程，它仅能使一个线程从运行(running)状态转到可运行           (ready)状态，而不是等待或阻塞状态  
  6.5 join()方法，存在thread中，表示让线程进入等待状态，如：t1.join()/t1.join(10)表示等待t1执行完毕/等待t1 10毫秒  
    
7.java中的守护线程：https://blog.csdn.net/shimiso/article/details/8964414  
  
8.java线程中的辅助：CountDownLatch、CyclicBarrier、Semaphore  (详细使用见mmpfiles)https://segmentfault.com/a/1190000015785789  
  8.1 CountDownLatch是一个同步的辅助类，允许一个或多个线程一直等待，直到其它线程完成它们的操作。  
  8.2 CyclicBarrier允许一组线程互相等待，直到到达某个公共屏障点。叫做cyclic是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用(对比于             CountDownLatch是不能重用的)  
  8.3 Semaphore(信号量)实际上就是可以控制同时访问的线程个数，它维护了一组"许可证"。  
     当调用acquire()方法时，会消费一个许可证。如果没有许可证了，会阻塞起来  
     当调用release()方法时，会添加一个许可证。  
     这些"许可证"的个数其实就是一个count变量罢了~   
       
9.LockSupport类：https://blog.csdn.net/hengyunabc/article/details/28126139  
  
10.java线程池：https://juejin.im/entry/58fada5d570c350058d3aaad  https://www.jianshu.com/p/87bff5cc8d8c  
   10.1 为什么使用线程池？  
   10.1.1 线程池是一种稀缺的资源，在并发量高的时候如果无限制的被创建不仅会消耗系统资源而且会降低系统的安全性，合理的利用线程池对线程进行统一的分配、           调优和监控很有必要，使用线程池主要有以下几个好处：  
        1)降低资源消耗    2)提高响应速度      3)提高线程的可管理性  
	  
   10.2 线程池创建的两种方式的比较：  
		  Executors各个方法的弊端：  
		  1) newFixedThreadPoolfPnewSingleThreadExecutor:  
		  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至00M。  
		  2) newCachedThreadPoolfPnewScheduledThreadPool:  
		  主要问題是线程数最大数是Integer.MAX_VALUE,可能会创建数置非常多的线程，甚至OOM。  
		  ExecutorService pool = Executors.newFixedThreadPool(3);  
		  推荐使用这种方式创建线程池，利于使用者理解各参数的作用，规避资源耗尽的风险  
		ThreadPoolExecutor pool=new ThreadPoolExecutor(3,5,0L,TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable>(3));  
	  
   10.3 创建线程池几个重要的参数：  
    10.3.1 corePoolSize：核心线程数，当提交一个任务时，线程池会创建一个线程执行任务，直到线程数等于corePoolSize  
    10.3.2 maximumPoolSize：线程中允许的最大线程数，如果提交的任务数大于核心线程数，则会把任务放进阻塞队列中去，前提是任务数小于maximumPoolSize,            如果阻塞队列满了则将创建新的线程执行任务。  
    10.3.3 keepAliveTime：线程的空闲存活时间，即当前程没有任务执行时继续存活的时间；默认情况下该参数在线程数大于corePoolSize的情况下才会有效  
    10.3.4 unit：keepAliveTime的单位  
    10.3.5 workQueue：用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：  
      1) ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；  
      2) LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；  
      3) SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于                                LinkedBlockingQuene；  
      4) priorityBlockingQuene：具有优先级的无界阻塞队列；  
        
    10.3.6 threadFactory: 创建线程的工厂，可以通过自定义线程工厂为线程指定名字  
      
    10.3.7 handler：饱和策略，如果阻塞队列满了且没有可执行任务的线程，而任务又必须要提交，则必须要采用一种饱和策略来处理该任务：  
        1)AbortPolicy：直接抛出异常，默认策略；  
        2)CallerRunsPolicy：用调用者所在的线程来执行任务；  
        3)DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；  
        4)DiscardPolicy：直接丢弃任务；  
        
        

                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
                                
   
            

# MySQL数据库
1.mysql中两种主要的存储引擎MyISAM与InnoDB的区别  
  
  1.1 InnoDB存储引擎支持事务、行锁设计、支持外键，但是默认的读取不会产生锁。InnoDB通过使用多版本并发控制(MVCC)来获得高并发性，并实现了SQL默认的4种隔离级别，默认状态下是Repeattable，使用next-key locking来避免幻读问题，除此之外还提供了插入缓冲、二次写、自适应哈希索引、预读等高可用功能，表中数据的存储采用了聚集的方式。  
  1.2 MyISAM存储引擎不支持事务、表锁设计，支持全文索引，它的缓冲池只缓存索引文件而不缓存数据文件  
  
2. 数据库的4种隔离级别，每种级别可能会存在的问题  
  2.1 未提交读(read uncommitted) 可能会造成脏读问题，即读取到还未提交的事务操作的数据  
  2.2 提交读(read committed) 修复了脏读问题，但可能会造成不可重复读问题，即读取到已经提交的数据  
  2.3 重复读(repeatable read) 是MySQL默认的隔离级别，修复了脏读、不可重复读的问题，但可能会造成幻读问题，使用next-key locking解决了这一问题
  2.4 可序列化读(serializable) 最严格的级别避免了所有的问题，但是资源开销很大  
  
3. MySQL中的锁  
  3.1 数据库中使用锁是为了对资源进行并发访问，并提高数据一致性和完整性。  
  3.2 lock与latch： lock的对象是事务，如表、页、行，lock对象一般在事务commit或者rollback后进行释放   
                      lock                                                latch  
      对象             事务                                                线程  
      保护             数据库的内容                                         内存数据结构
      持续时间         整个事务过程                                          临界资源  
      模式             表锁、行锁、页锁                                      读写锁、互斥量  
      死锁             通过资源等待图和超时机制进行检测                        无死锁检测机制  
      存在于           lock manager的hash表中                                每个数据结构对象  
  
4. 锁的类别  
   mysql中最主要有两种锁： 
   共享锁：S Lock允许事务读一行数据  
   排它锁(悲观锁)：X Lock允许事务删除一行数据  
   乐观锁通过MVCC实现  
   InnoDB存储引擎为了支持在不同的粒度上进行加锁，而引入了一种额外的加锁方式，意向锁：  
   意向共享锁：IS Lock 获得表中某几行的共享锁  
   意向排它锁：IX Lock 获得表中某几行的排他锁  
   select ... from ... lock in share mode  加共享锁  
   select ... from ... for update 加排他锁  
  
5.一致性非锁定读  
   指的是innoDB引擎通过多版本并发控制来读取当前执行时间数据库中行数据，如果正在执行update或者delete操作，这时读取操作不会等待锁的释放，而是去读取一个快照数据(指的是改行之前版本的数据，听过undo实现)，这样大大提高了并发性。  
     
6.锁的三种算法：  
  6.1 Record Lock：单个行记录上的锁  
  6.2 Gap Lock：间隙锁，锁定一个范围，但不包含记录本身  
  6.3 Next-key Lock：前两者的集合，并且锁定本身，查询的索引含有唯一性属性时会进行降级为record lock仅锁住索引本身  
  
7.死锁的判定原理  
7.1 概念：两个或两个以上的事务在执行的过程中，因争夺资源而造成的一种互相等待的现象
7.2 死锁的检测：wait-for graph
7.3 死锁的解决:超时机制，当等待的时间超过某个设置的阈值时，其中一个事务进行回滚。  
  
8.索引  
  8.1 聚集索引：按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，叶子节点也叫数据页，聚集索引能够在B+树叶子节点上直接找到数                据。  
  8.2 非聚集索引：叶子节点不包含表的全部数据，叶子节点中存放着键值，以及一个书签用于告诉InnoDB引擎在哪可以找到这些行数据。 
    
9.B+树索引和hash索引的区别  
  9.1 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；    
  9.2 从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；  
  9.3 同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；  
  9.4 哈希索引也不支持多列联合索引的最左匹配规则；  
  9.5 B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。  
    
10.B+树索引和B树索引的区别：
   B-树和B+树最重要的一个区别就是B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数
   那么Mysql如何衡量查询效率呢？磁盘IO次数，B-树（B类树）的特定就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，当查询数据的时候，最好的情况就是很快找到目标索引，然后读取数据，使用B+树就能很好的完成这个目的，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时啊！），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。  
另一个优点是什么，B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。  
(数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）)  
  
11.MySQL的中的日志  
  11.1 错误日志：对MySQL的启动、运行、关闭过程进行记录，可通过错误日志定位MySQL存在的问题  
  11.2 慢查询日志：定位存在问题的SQL语句，从而进行SQL语句层面的优化，在默认的情况下MySQL数据库并不启动慢查询日志，需要手动开启。  
  11.3 查询日志：记录了所有对MySQL的请求信息。 
  11.4 二进制日志：记录了对MySQL数据库执行更改的所有操作，但是不包括show和select这类没有对数据库进行修改的操作。  
       作用：  
       1)恢复 2)复制 3)审计  
   
  11.5 重做日志(redo)：重做日志文件用于实现事务的持久性。由两部分组成：  
                      1)是内存中的重做日志缓冲，是易失的  
                      2)是重做日志文件，是持久的，事务提交时必须将事务的日志全部写入重做日志文件进行持久化，待事务的commit操作完成才算完成，但是在                         数据库中也允许非持久化的操作，为了提高数据库的性能，可每隔一段时间才进行一次将事务日志从日志缓存中写入重做日志  
                      3)事务提交时的操作：  
                      ①修改内存中对应的事务信息，并且将日志写入重做日志缓冲  
                      ②调用fsync将确保日志都被从重做日志缓冲写入磁盘  
   
       二进制日志和重做日志的区别：二进制日志主要用来进行pointtotime的恢复及主从复制环境的建立，它在数据库的上层产生，是一种逻辑日志，对应的是SQL语                                 句，它不只针对InNoDB存储引擎，数据库中的任何引擎对数据库的修改都会产生二进制日志，在事务提交完成后对它进行一次修                                   改。  
                                重做日志在InNoDB存储引擎层产生，它是一种物理格式日志，记录的是对每个页的修改。  
  
   11.6 undo日志：用来帮助事务进行回滚和MVCC功能，当执行rollback语句时可利用undo信息将数据回滚到修改前的样子(并不是事务开始前的样子)  
   11.7 purge：用于完成delete和update的最终操作，当执行一条delete语句时，记录并不会直接被删除，而只是将delete flag标记为1，标记已删除，最终的删除                任务由purge完成  
  
12.数据库的读写分离  
   12.1 原理：是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。  
   12.2 why：数据库的写操作很费时，但是读操作很快，将这两个操作分开提高了查询的效率。  
   12.3 when：数据库不一定要读写分离，如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用，利用数据库 主从同步 。可以减少数据库压力，提高性能。  
  
13.主从复制  
   在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足实际需求的。无论是在安全性、高可用性还是高并发等各个方面都是完全不能满足实际需求的。因此，通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发负载能力。mysql主从复制是对数据库中的数据、语句做备份。  
   13.1 what：MySQL主从复制是其最重要的功能之一。主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。对于多级复制，数据库服务器即可充当主机，也可充当从机。MySQL主从复制的基础是主服务器对数据库修改记录二进制日志，从服务器通过主服务器的二进制日志自动执行更新。  
  
   13.2主从复制的类型：
   1)基于语句的复制：主服务器上面的语句在从服务器再执行一遍  
   2)基于行的复制：把主服务器中改变的内容直接复制给从服务器，而不关心是由什么语句引起的  
   3)混合类型的复制：MySQL默认使用基于语句的复制，当基于语句的复制会引发问题的时候就会使用基于行的复制，MySQL会自动进行选择  
   13.3主从复制的原理：https://segmentfault.com/a/1190000008942618  
  
14.sql语句的执行过程  
   https://blog.csdn.net/sinat_32176267/article/details/83280206
    
15.mysql索引优化  
  15.1 索引类型：  
       主键索引：特殊的唯一标识，不允许为空值，mysql会自动为主键列添加唯一索引，所以主键列不必再添加唯一索引  
       唯一索引：索引列必须唯一，但是允许有null  
       ALTER TABLE table_name ADD UNIQUE (column)  
       普通索引：最基本的索引，没有限制，可以在表创建的时候创建也可以通过修改表结构进行创建  
       alter table table_name add index index_name(column_name);  
       组合索引：一个索引包含多个列  
       alter table table_name add index index_name(column_name1,column_name2......);  
       全文索引：全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，然                 后按照一定的算法规则智能地筛选出我们想要的搜索结果。  
       ALTER TABLE table_name ADD FULLTEXT (column)  
         
  15.2 建立索引的原则：  
       1)最左前缀匹配原则：对于多列的组合索引，从列的最左边开始匹配，中间不能跳过，所以在创建组合索引时，在where子句中使用最频繁的放在左边，如果跳过                           最左边的列使用右边的列进行查询将导致全表扫描，索引无效。  
       2)选择区分度高的列作为索引，比如学号而不是性别  
       3)in和=可以乱序，SQL的语句优化器会优化为索引可以识别的顺序  
       4)索引列不能参加计算，如果列参加计算的话每次索引时都会进行计算一次，成本很高。  
       5)能进行索引的扩展就不进行索引的创建，index(a)----->index(a,b)  
         
  15.3 以下情况索引会失效：  
       1)like的参数以通配符开头，如：like '%海松'   
       2)where条件不符合最左前缀匹配原则  
       3)使用！=，<>操作符时  
       4)索引列参与计算  
       5)对字段进行null值判断  
       6)使用or来连接条件  
         
  15.4 索引优化总结：https://cloud.tencent.com/developer/article/1004912  
       1)避免使用select(*)，在解析的过程中会将'*' 依次转换成所有的列名，这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间。  
       2)order by语句优化：order by语句中的任何非索引列或有计算表达式的都会降低查询的速度  
       ①重写order by语句使用索引  
       ②为索引项添加索引③绝对避免在子句中使用表达式   
       3)group by优化：在group by之前将不需要的字段过滤掉，先where再group by  
       4)使用exists替代in  
       5)join语句优化：如果应用程序有很多JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制   
  
16.使用explain优化SQL语句：https://blog.csdn.net/zbw18297786698/article/details/54349046  
  
# java IO与NIO  
1.NIO介绍：https://blog.csdn.net/suifeng3051/article/details/48160753  
          https://blog.yoodb.com/yoodb/article/detail/1498  
  
# java消息队列  
 1.https://blog.csdn.net/qq_34337272/article/details/80029918  
 2.ActiveMQ：
 3.RabbitMQ：https://www.jianshu.com/p/79ca08116d57  
 4.RocketMQ：https://www.jianshu.com/p/824066d70da8  
       
# 面向对象https://blog.csdn.net/jiyiqinlovexx/article/details/46593053
1.面向的特征和原则
1.1基本特征：多态、继承、封装  
1.2基本原则：单一职责原则、开放封闭原则、替换原则、依赖原则、接口分离原则  
2.java中的值传递和引用传递https://juejin.im/post/5bce68226fb9a05ce46a0476#heading-10  
2.1值传递：在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。  
2.2引用传递：”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。  
3.java中的枚举：https://blog.csdn.net/qq_27093465/article/details/52180865  

       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
   

   
                                
                      
                      




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  







